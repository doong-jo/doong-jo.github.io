<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- Basic SEO -->
    <title>디자인 시스템이 레거시가 되는 순간 | doong-jo</title>
    <meta
      name="description"
      content="Props 지옥에서 벗어나 확장 가능한 디자인 시스템을 만드는 Compound Pattern 활용법"
    />
    <meta name="author" content="Sungdong Cho" />
    <meta name="keywords" content="Compound Pattern, React, 디자인 시스템, Design System, Component, Props" />
    <meta name="post-tags" content="React, 디자인시스템" />

    <!-- Canonical -->
    <link
      rel="canonical"
      href="https://doong-jo.github.io/posts/compound_pattern%EC%9D%84_%EB%AA%A8%EB%A5%B8%EB%8B%A4%EB%A9%B4_%EB%8B%B9%EC%8B%A0%EC%9D%B4_%EB%A7%8C%EB%93%A0_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80_%EA%B3%A7_%ED%8F%90%EA%B8%B0%ED%95%B4%EC%95%BC%ED%95%A0%EC%A7%80%EB%8F%84_%EB%AA%A8%EB%A6%85%EB%8B%88%EB%8B%A4.html"
    />

    <!-- RSS Feed -->
    <link
      rel="alternate"
      type="application/rss+xml"
      title="doong-jo RSS Feed"
      href="https://doong-jo.github.io/feed.xml"
    />

    <!-- Open Graph -->
    <meta property="og:type" content="article" />
    <meta property="og:title" content="디자인 시스템이 레거시가 되는 순간" />
    <meta
      property="og:description"
      content="Props 지옥에서 벗어나 확장 가능한 디자인 시스템을 만드는 Compound Pattern 활용법"
    />
    <meta
      property="og:url"
      content="https://doong-jo.github.io/posts/compound_pattern%EC%9D%84_%EB%AA%A8%EB%A5%B8%EB%8B%A4%EB%A9%B4_%EB%8B%B9%EC%8B%A0%EC%9D%B4_%EB%A7%8C%EB%93%A0_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80_%EA%B3%A7_%ED%8F%90%EA%B8%B0%ED%95%B4%EC%95%BC%ED%95%A0%EC%A7%80%EB%8F%84_%EB%AA%A8%EB%A6%85%EB%8B%88%EB%8B%A4.html"
    />
    <meta property="og:site_name" content="doong-jo" />
    <meta property="og:locale" content="ko_KR" />
    <meta property="og:image" content="https://doong-jo.github.io/resources/images/design-system.jpg" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="article:author" content="Sungdong Cho" />
    <meta property="article:published_time" content="2026-01-26" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="디자인 시스템이 레거시가 되는 순간" />
    <meta
      name="twitter:description"
      content="Props 지옥에서 벗어나 확장 가능한 디자인 시스템을 만드는 Compound Pattern 활용법"
    />
    <meta name="twitter:image" content="https://doong-jo.github.io/resources/images/design-system.jpg" />

    <!-- JSON-LD: BlogPosting Schema -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "디자인 시스템이 레거시가 되는 순간",
        "description": "Props 지옥에서 벗어나 확장 가능한 디자인 시스템을 만드는 Compound Pattern 활용법",
        "image": "https://doong-jo.github.io/resources/images/design-system.jpg",
        "author": {
          "@type": "Person",
          "name": "Sungdong Cho",
          "url": "https://doong-jo.github.io/about.html"
        },
        "publisher": {
          "@type": "Person",
          "name": "Sungdong Cho"
        },
        "datePublished": "2026-01-26",
        "dateModified": "2026-01-26",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://doong-jo.github.io/posts/compound_pattern%EC%9D%84_%EB%AA%A8%EB%A5%B8%EB%8B%A4%EB%A9%B4_%EB%8B%B9%EC%8B%A0%EC%9D%B4_%EB%A7%8C%EB%93%A0_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80_%EA%B3%A7_%ED%8F%90%EA%B8%B0%ED%95%B4%EC%95%BC%ED%95%A0%EC%A7%80%EB%8F%84_%EB%AA%A8%EB%A6%85%EB%8B%88%EB%8B%A4.html"
        },
        "inLanguage": "ko-KR"
      }
    </script>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="../common/common.css" />
    <link rel="stylesheet" href="../nav/nav.css" />
    <link rel="stylesheet" href="../post/post.css" />
    <link rel="stylesheet" href="../post/prism.css" />
    <style></style>
  </head>
  <body>
    <nav>
      <h1><a href="/">doong-jo</a></h1>
      <ul id="nav-list">
        <li><a href="/index.html" id="nav-post" class="current">Post</a></li>
        <li><a href="/about.html" id="nav-about">About</a></li>
      </ul>
    </nav>
    <div class="content">
      <main>
        <time>2026-01-26</time>
        <div class="post-tags">
          <span class="tag">React</span>
          <span class="tag">디자인시스템</span>
        </div>
        <img
          src="../resources/images/design-system.jpg"
          alt="디자인 시스템"
          style="width: 100%; max-width: 100%; height: auto; margin-bottom: 4px; border-radius: 8px"
        />
        <p style="font-size: 0.75rem; color: #666; margin-bottom: 24px">
          사진:
          <a
            href="https://unsplash.com/ko/%EC%82%AC%EC%A7%84/%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%95%84%EC%9D%B4%EC%BD%98%EC%9D%84-%ED%91%9C%EC%8B%9C%ED%95%98%EB%8A%94-%EB%A7%A5%EB%B6%81-%ED%94%84%EB%A1%9C-o1SKqmgSDbg?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"
            target="_blank"
            >Unsplash</a
          >의
          <a
            href="https://unsplash.com/ko/@tirzavandijk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"
            target="_blank"
            >Tirza van Dijk</a
          >
        </p>
        <h1>디자인 시스템이 레거시가 되는 순간</h1>

        <h2>우리가 그리는 이상적인 디자인 시스템</h2>
        <p>
          디자인 시스템을 만들기로 했을 때, 우리는 아름다운 미래를 상상합니다. 일관된 UI/UX, 재사용 가능한 컴포넌트들,
          개발 속도의 비약적 향상. 디자이너와 개발자 사이의 원활한 협업. 한 번 만들어두면 모든 팀이 행복해지는 마법 같은
          것을 기대하죠.
        </p>
        <p>
          "Button 하나 잘 만들어두면 앞으로 버튼 걱정은 없겠지?"<br />
          "Modal도 만들어두자. 옵션 몇 개 넣어두면 어디서든 쓸 수 있을 거야."
        </p>
        <p>그렇게 디자인 시스템 프로젝트가 시작됩니다.</p>

        <h2>진짜 현실에서의 디자인 시스템</h2>
        <p>
          몇 달이 지났습니다. 처음엔 5개였던 Modal의 props가 어느새 20개를 넘어가고 있습니다. 새로운 요구사항이 들어올
          때마다 props가 하나씩 추가되고, 컴포넌트 내부는 조건문으로 가득 차게 됩니다. (실제로 제가 겪었던 경험입니다.)
        </p>
        <pre><code class="language-typescript">// 처음엔 이랬는데...
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: ReactNode;
}

// 6개월 후
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  showHeader?: boolean;
  showFooter?: boolean;
  showCloseButton?: boolean;
  closeButtonPosition?: 'left' | 'right';
  size?: 'sm' | 'md' | 'lg';
  // ... 20개 넘는 props
}</code></pre>
        <p>
          이 상태에서 디자이너가 말합니다. "이번 피처에서는 Footer에 버튼이 3개 필요해요. 그리고 Body 영역 레이아웃은 이
          화면에서만 다르게 디자인해서 쓰고 싶어요."
        </p>
        <p>
          <strong>Props 지옥에 오신 것을 환영합니다.</strong>
        </p>
        <p>
          물론 이건 디자이너의 잘못이 아닙니다. 그들은 그들의 일을 할 뿐입니다. 세부적인 디자인은 비즈니스 요구사항에
          따라 얼마든지 바뀔 수 있고, 바뀌어야만 합니다. 화면 위에 떠있는 형태와 모달이 열리고 닫히는 것과 같은 핵심
          기능이 바뀌는 게 아니라면, 디자인은 자연스러운 변화를 겪을 수 있습니다. UI 구조의 변화는 자연스러운 일입니다.
          문제는 그 변화를 수용하지 못하는 컴포넌트 설계에 있습니다.
        </p>
        <p>앞으로 다가올 문제는 아래와 같습니다.</p>
        <ul>
          <li>새로운 요구사항마다 props가 추가됨</li>
          <li>props 조합의 폭발적 증가로 테스트가 불가능해짐</li>
          <li>컴포넌트 내부 조건문이 복잡해져 유지보수가 어려워짐</li>
          <li>결국 "이 컴포넌트 너무 복잡해서 새로 만들자"라는 결론에 도달</li>
        </ul>
        <p>
          어떻게 확신하냐고요? 2개의 팀에서 겪었고 주변에서도 겪는 모습들 그리고 유명한 오픈소스들이 (현재는 그렇지
          않지만)실제로 그러했기 때문입니다.
        </p>
        <h2>Compound Pattern이 확장성 문제를 어떻게 해결하는가</h2>
        <p>
          Compound Pattern은 <strong>구조에 대한 책임을 컴포넌트가 아닌 사용하는 쪽에 위임</strong>하는 방식입니다.
          HTML의 <code>&lt;select&gt;</code>와 <code>&lt;option&gt;</code>의 관계를 생각해보세요.
        </p>
        <pre><code class="language-markup">&lt;select&gt;
  &lt;option value="a"&gt;선택지 A&lt;/option&gt;
  &lt;option value="b"&gt;선택지 B&lt;/option&gt;
  &lt;option value="c"&gt;선택지 C&lt;/option&gt;
&lt;/select&gt;</code></pre>
        <p>
          <code>&lt;select&gt;</code>는 <code>option1</code>, <code>option2</code>, <code>option3</code> 같은 props를
          받지 않습니다. 대신 자식으로 <code>&lt;option&gt;</code>들을 받고, 그것들과 암묵적으로 상태를 공유합니다.
          이것이 Compound Pattern의 핵심입니다.
        </p>
        <p>이제 Modal을 Compound Pattern으로 리팩토링해봅시다.</p>
        <pre><code class="language-tsx">// Context로 상태 공유
const ModalContext = createContext&lt;{ onClose: () =&gt; void } | null&gt;(null);

// Root: 핵심 props만 관리
function Modal({ isOpen, onClose, children }: ModalProps) {
  if (!isOpen) return null;
  return (
    &lt;ModalContext.Provider value={{ onClose }}&gt;
      &lt;div className="modal"&gt;{children}&lt;/div&gt;
    &lt;/ModalContext.Provider&gt;
  );
}

// 서브 컴포넌트들
Modal.Header = ({ children }) =&gt; &lt;header&gt;{children}&lt;/header&gt;;
Modal.Body = ({ children }) =&gt; &lt;main&gt;{children}&lt;/main&gt;;
Modal.Footer = ({ children }) =&gt; &lt;footer&gt;{children}&lt;/footer&gt;;
Modal.CloseButton = ({ children }) =&gt; {
  const { onClose } = useContext(ModalContext);
  return &lt;button onClick={onClose}&gt;{children}&lt;/button&gt;;
};</code></pre>
        <p>이제 사용하는 쪽에서 구조를 자유롭게 결정할 수 있습니다.</p>
        <pre><code class="language-tsx">// 기본 구조
&lt;Modal isOpen={isOpen} onClose={handleClose}&gt;
  &lt;Modal.Header&gt;제목&lt;/Modal.Header&gt;
  &lt;Modal.Body&gt;내용&lt;/Modal.Body&gt;
  &lt;Modal.Footer&gt;&lt;Modal.CloseButton&gt;닫기&lt;/Modal.CloseButton&gt;&lt;/Modal.Footer&gt;
&lt;/Modal&gt;

// 구조 변경이 필요하면? props 추가 없이 그냥 바꾸면 됨
&lt;Modal isOpen={isOpen} onClose={handleClose}&gt;
  &lt;Modal.Body&gt;
    &lt;p&gt;간단한 알림&lt;/p&gt;
    &lt;Modal.CloseButton&gt;확인&lt;/Modal.CloseButton&gt;
  &lt;/Modal.Body&gt;
&lt;/Modal&gt;</code></pre>
        <p>
          Props 지옥 Modal에서는 "Footer에 버튼 3개, 가운데는 아이콘"이라는 요구사항에 새로운 props를 추가해야 했습니다.
          하지만 Compound Pattern에서는 그냥 사용하는 쪽에서 원하는 대로 조합하면 됩니다.
          <strong>새로운 props 없이요.</strong>
        </p>
        <p>이것이 Compound Pattern의 힘입니다:</p>
        <ul>
          <li><strong>구조의 자유도</strong>: 사용처마다 다른 구조가 필요해도 컴포넌트 수정 불필요</li>
          <li><strong>Props 최소화</strong>: Root 컴포넌트는 핵심 상태(isOpen, onClose)만 관리</li>
          <li><strong>관심사 분리</strong>: 각 서브 컴포넌트는 자신의 역할에만 집중</li>
          <li><strong>확장 용이</strong>: 새로운 서브 컴포넌트 추가가 기존 코드에 영향 없음</li>
        </ul>

        <h2>닭 잡는데 소 잡는 칼을 쓰지 마세요</h2>
        <p>Compound Pattern이 만능은 아닙니다. 모든 컴포넌트에 적용하면 오히려 복잡해집니다.</p>
        <p><strong>Compound Pattern이 적합한 경우</strong></p>
        <ul>
          <li>복잡한 UI 구조를 가진 컴포넌트 (Modal, Accordion, Tabs, Menu, Card)</li>
          <li>자식 컴포넌트들 간에 상태 공유가 필요한 경우</li>
          <li>사용처마다 구조가 유연하게 달라져야 하는 경우</li>
        </ul>
        <p><strong>Compound Pattern이 적합하지 않은 경우</strong></p>
        <ul>
          <li>단순한 컴포넌트 (Button, Input, Badge, Avatar)</li>
          <li>구조가 항상 고정된 컴포넌트</li>
          <li>Props 몇 개로 충분히 커버되는 컴포넌트</li>
        </ul>
        <pre><code class="language-tsx">// Button은 그냥 props로 충분
&lt;Button variant="primary" loading={isLoading}&gt;저장&lt;/Button&gt;</code></pre>
        <p><strong>Compound Pattern의 단점</strong></p>
        <ul>
          <li><strong>러닝 커브</strong>: 처음 접하는 개발자에게는 Context와 서브 컴포넌트 구조가 낯설 수 있음</li>
          <li>
            <strong>설계 시 커뮤니케이션 비용</strong>: 어떤 서브 컴포넌트를 만들지, 어떤 상태를 공유할지 팀 내 합의
            필요
          </li>
        </ul>
        <p>
          하지만 확장성을 챙기지 않았을 때의 비용을 생각해보세요. Props가 20개를 넘어가는 컴포넌트를 유지보수하거나,
          결국 "새로 만들자"며 처음부터 다시 개발하는 비용에 비하면 충분히 감수할 만합니다.
        </p>

        <h2>요약</h2>
        <ol>
          <li>
            <strong>디자인 시스템은 Props 지옥에 빠지기 쉽습니다.</strong> 요구사항이 쌓일수록 props는 늘어나고,
            컴포넌트는 복잡해집니다.
          </li>
          <li>
            <strong>Compound Pattern은 구조의 책임을 사용하는 쪽에 위임합니다.</strong> 덕분에 새로운 요구사항에도
            컴포넌트 수정 없이 대응할 수 있습니다.
          </li>
          <li>
            <strong>복잡한 UI 컴포넌트에 적합합니다.</strong> Modal, Accordion, Tabs 같이 구조가 유연해야 하는
            컴포넌트에 사용하세요.
          </li>
          <li><strong>모든 곳에 적용하지 마세요.</strong> 단순한 컴포넌트는 그냥 props가 낫습니다.</li>
        </ol>
        <p>
          디자인 시스템의 수명은 확장성에 달려있습니다. Compound Pattern을 잘 활용하면, "이 컴포넌트 복잡해서 새로
          만들자"라는 말 대신 "그냥 조합만 바꾸면 되네"라는 말을 듣게 됩니다.
        </p>

        <div class="back-to-list">
          <a href="/index.html" class="back-button">← 글 목록으로 돌아가기</a>
        </div>
      </main>
      <script
        src="https://utteranc.es/client.js"
        repo="doong-jo/doong-jo.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async
      ></script>
    </div>
    <script src="../common/common.js"></script>
    <script src="../nav/nav.js"></script>
    <script src="../post/prism.js"></script>
  </body>
</html>

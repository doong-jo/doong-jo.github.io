"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[280],{6678:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(7294),r=n(5414),l=function(){var e=(0,a.createRef)(),t=(0,a.useState)("pending"),n=t[0],r=t[1],l=(0,a.useState)(!1),i=l[0],o=l[1];return(0,a.useEffect)((function(){if(!i){var t=document.createElement("script");t.onload=function(){return r({status:"success"})},t.onerror=function(){return r({status:"failed"})},t.async=!0,t.src="https://utteranc.es/client.js",t.setAttribute("repo","doong-jo/blog"),t.setAttribute("issue-term","pathname"),t.setAttribute("theme","preferred-color-scheme"),t.setAttribute("crossorigin","anonymous"),e.current.appendChild(t),o(!0)}}),[i,e]),a.createElement("div",{className:"comments-wrapper"},"failed"===n&&a.createElement("p",null,"Error. Please try again."),"pending"===n&&a.createElement("p",null,"Loading script..."),a.createElement("div",{ref:e}))},i=n(9327);function o(e){var t=e.children,n=e.pageContext.frontmatter,o=n.title,p=n.description,m=n.keywords,u=n.url,k=n.image,c=n.date;return a.createElement(a.Fragment,null,a.createElement("header",null,a.createElement("a",{href:"/"},"Home")),a.createElement("div",{id:"post-body",className:"markdown-body dark"},a.createElement(i.Z,null),a.createElement(r.Z,null,a.createElement("title",null,o),a.createElement("meta",{name:"description",content:p}),a.createElement("meta",{name:"keywords",content:m}),a.createElement("meta",{name:"author",content:"doong-jo"}),a.createElement("meta",{property:"og:type",content:"website"}),a.createElement("meta",{property:"og:title",content:o}),a.createElement("meta",{property:"og:site_name",content:o}),a.createElement("meta",{property:"og:description",content:p}),a.createElement("meta",{property:"og:image",content:k}),a.createElement("meta",{property:"og:url",content:u}),a.createElement("meta",{name:"twitter:title",content:o}),a.createElement("meta",{name:"twitter:description",content:p}),a.createElement("meta",{name:"twitter:image",content:k}),a.createElement("link",{rel:"canonical",href:u})),a.createElement("time",null,c),t,a.createElement(l,null)))}},2420:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return o},default:function(){return u}});var a=n(3366),r=(n(7294),n(4983)),l=n(6678),i=["components"],o={},p={_frontmatter:o},m=l.Z;function u(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)(m,Object.assign({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",null,"CSS 안에 자바스크립트 넣기"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"원문: ",(0,r.kt)("a",{parentName:"p",href:"https://blog.devgenius.io/putting-javascript-in-your-css-c1af716cbae9?gi=4e4dcc27bf43"},"Putting JavaScript In Your CSS"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"물론입니다. CSS 안에 JS를 사용하는 것은 가능합니다.")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/700/0*KoxC9Y5G0fyXOAIE",alt:"img1"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Photo by Jackson Sophat on Unsplash")),(0,r.kt)("p",null,"개발자 입장에서 Javascript 안에 CSS를 사용해본 적이 있을 겁니다. 하지만 오늘은 CSS 내부에 Javascript를 작성하는 것을 보여드리고자 합니다."),(0,r.kt)("p",null,"그 방법으로 후디니(Houdini)라고 알려진 CSS low-level API가 있으며, 개발자는 브라우저 렌더링 엔진의 styling과 layout 프로세스를 후킹하여 CSS를 확장가능하도록 합니다."),(0,r.kt)("p",null,"후디니는 ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement.style")," 같은 자바스크립트를 통한 스타일 변경보다 파싱을 더 빠르게 할 수 있습니다. 브라우저는 스크립트에서 어떠한 스타일 변경을 적용하기 전에 CSSOM을 파싱하고 레이아웃, 페인트, 컴포지트(compsite)하는 프로세스를 거칩니다.\n후디니 코드는 첫번째 렌더링 사이클이 끝나기를 기다리지 않습니다. 오히려 첫번째 사이클에 포함되어 렌더링 가능하고 이해하기 쉬운 스타일을 만듭니다. 후디니는 자바스크립트 내에 CSS 값으로 작업하기 위한 객체 기반의 API를 제공합니다."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"후디니의 ",(0,r.kt)("inlineCode",{parentName:"p"},"CSS Typeed OM API"),"는 타입과 메서드가 포함된 CSS 객체 모델이며, 값을 자바스크립트 객체로 노출하여 이전 문자열 기반 ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement.style")," 조작보다 직관적인 CSS 조작을 가능하게 합니다. 모든 요소 및 스타일 시트 규칙에는 ",(0,r.kt)("inlineCode",{parentName:"p"},"StylePropertyMap")," 을 통해 접근 할 수 있는 스타일 맵이 있습니다."),(0,r.kt)("p",null,"CSS 후디니의 기능 중 하나는 ",(0,r.kt)("inlineCode",{parentName:"p"},"Worklet")," 입니다. worklet을 사용하면 CSS 모듈을 생성할 수 있는데요. 이 모듈 방식은 전처리 프로세서, 후처리 프로세서 또는 자바스크립트 프레임워크 없이 한 줄의 자바스크립트로 가져올 수 있습니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'CSS.paintWorklet.addModule("csscomponent.js");\n')),(0,r.kt)("p",null,"이 모듈은 완전히 구성 가능한 worklet을 등록하는 ",(0,r.kt)("inlineCode",{parentName:"p"},"PaintWorklet.registerPaint")," 함수가 포함되어 있습니다."),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"Paint Worklets 지원 여부"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/700/1*-OksJ4t4pG4DHMZ-4M_X0Q.png",alt:"img2"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"CSS Paint API 호환성 통계")),(0,r.kt)("p",null,"CSS ",(0,r.kt)("inlineCode",{parentName:"p"},"paint()")," 함수는 ",(0,r.kt)("inlineCode",{parentName:"p"},"<image>")," 타입에서 지원되는 추가 기능입니다. worklet의 이름과 함께 worklet에 추가적으로 필요한 매개변수를 인자로 받습니다. worklet은 사용자 지정 속성에 대한 권한도 가지고 있습니다. 따라서 이 속성들은 함수 인수로 전달할 필요가 없습니다."),(0,r.kt)("p",null,"이 예시에서는 ",(0,r.kt)("inlineCode",{parentName:"p"},"paint()")," 함수에 ",(0,r.kt)("inlineCode",{parentName:"p"},"myComponent")," 라는 worklet이 전달됩니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"li {\n  background-image: paint(myComponent, stroke, 10px);\n  --highlights: blue;\n  --lowlights: green;\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h3",null,"Houdini APIs"),(0,r.kt)("p",null,"아래에서 Houdini의 범위에 있는 API를 찾을 수 있습니다."),(0,r.kt)("h3",null,"CSS 프로퍼티 그리고 Values API"),(0,r.kt)("p",null,"새로운 CSS 프로퍼티를 등록하기 위한 API를 정의합니다. 이 API를 사용하여 등록된 프로퍼티는 타입, 상속 초기값을 정의한 해석된 구문을 제공합니다."),(0,r.kt)("h3",null,"CSS Typed OM"),(0,r.kt)("p",null,"CSSOM 값 문자열을 의미 있는 자바스크립트 표현으로 변환하고 다시 변환하면 상당한 성능 오버헤드가 발생할 수 있습니다. CSS Typed OM은 CSS 값을 형식화된 자바스크립트 객체로 보여주고 성능 조작을 허용합니다."),(0,r.kt)("h3",null,"CSS Painting API"),(0,r.kt)("p",null,"CSS의 확장성을 향상시키기 위해 개발된 Painting API는 개발자가 ",(0,r.kt)("inlineCode",{parentName:"p"},"paint()")," CSS 함수를 통해 요소의 배경, 테두리 또는 콘텐츠로 직접 그릴 수 있는 자바스크립트 함수를 작성할 수 있도록 합니다."),(0,r.kt)("h3",null,"Worklet"),(0,r.kt)("p",null,"기본 자바스크립트 실행 환경과 독립적인 렌더링 파이프라인의 다양한 단계에서 스크립트를 실행하기 위한 API입니다. 워크렛은 개념적으로 웹 워커와 유사하며 렌더링 엔진에 의해 호출되고 확장됩니다."),(0,r.kt)("h3",null,"CSS Layout API"),(0,r.kt)("p",null,"CSS의 확장성을 향상시키기 위해 설계된 이 API를 통해 개발자는 masonary 또는 line snapping과 같은 자체 레이아웃 알고리즘을 작성할 수 있습니다."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"(역주) masonary: 핀터레스트에서 대표적으로 사용하는 레이아웃으로 이미지를 효과적으로 배치하는 레이아웃입니다. 자세한 내용은 ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Masonry_Layout"},"MDN"),"을 참고하세요.\n(역주) line snapping: 자세한 내용은 ",(0,r.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/css-line-grid-1/#propdef-line-snap"},"w3c"),"를 참고하세요.")),(0,r.kt)("h3",null,"CSS Parser API"),(0,r.kt)("p",null,"이 API는 임의의 CSS 유사 언어를 약간 유형화된 표현으로 구문 분석하기 위해 CSS 파서를 더 직접적으로 노출합니다."),(0,r.kt)("h3",null,"Font Metrics API"),(0,r.kt)("p",null,"폰트 메트릭을 노출하는 API를 통해 타이포그래픽 레이아웃 결과에 접근할 수 있습니다."),(0,r.kt)("hr",null),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"(“CSS Custom Paint” 또는 “Houdini의 paint worklet”로 알려지기도 한)CSS Paint API는 기본적으로 활성화되어 있습니다.")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"CSS Paint API를 사용하면 CSS 프로퍼티가 이미지를 예상할 때마다 프로그래밍 방식으로 이미지를 생성할 수 있습니다. ",(0,r.kt)("inlineCode",{parentName:"p"},"background-image")," 또는 ",(0,r.kt)("inlineCode",{parentName:"p"},"border-image"),"와 같은 속성은 일반적으로 이미지 파일을 로드하기 위해 ",(0,r.kt)("inlineCode",{parentName:"p"},"url()")," 또는 ",(0,r.kt)("inlineCode",{parentName:"p"},"linear-gradient()")," 와 같은 CSS 내장 함수와 함께 사용됩니다. 이러한 기능을 사용하는 대신 ",(0,r.kt)("inlineCode",{parentName:"p"},"paint(myPainter)")," 를 사용하여 ",(0,r.kt)("em",{parentName:"p"},"paint worklet"),"을 참조할 수 있습니다."),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"Paint worklet 작성하기"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"myPainter")," 라는 paint worklet을 정의하려면 ",(0,r.kt)("inlineCode",{parentName:"p"},"CSS.paintWorklet.addModule('my-paint-worklet.js')"),"을 사용하여 CSS paint worklet 파일을 로드해야 합니다. 해당 파일에서 ",(0,r.kt)("inlineCode",{parentName:"p"},"registerPaint")," 함수를 사용하여 paint worklet 클래스를 등록할 수 있습니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'class MyPainter {\n  paint(ctx, geometry, properties) {\n    // ...\n  }\n}\nregisterPaint("myPainter", MyPainter);\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"paint()")," callback에서 ",(0,r.kt)("inlineCode",{parentName:"p"},"<canvas>")," 로부터 알고 있는 ",(0,r.kt)("inlineCode",{parentName:"p"},"CanvasRenderingContext2D"),"와 같은 방법으로 ",(0,r.kt)("inlineCode",{parentName:"p"},"ctx")," 를 사용할 수 있습니다. 만약 ",(0,r.kt)("inlineCode",{parentName:"p"},"<canvas>")," 안에서 어떻게 그리는지 알고 있다면, paint worklet 안에서도 그릴 수 있습니다! ",(0,r.kt)("inlineCode",{parentName:"p"},"geometry")," 는 우리가 마음대로 쓸 수 있는 캔버스의 폭과 높이를 말해줍니다."),(0,r.kt)("p",null,"paint worklet의 문맥은 ",(0,r.kt)("inlineCode",{parentName:"p"},"<canvas>")," 와 100% 동일하지는 않습니다. 현재로서는 텍스트 렌더링 방법이 없으며 보안상의 이유로 캔버스에서 픽셀을 다시 읽을 수 없습니다."),(0,r.kt)("p",null,"입문 예시로, 체커보드 paint worklet을 작성하여 ",(0,r.kt)("inlineCode",{parentName:"p"},"<textarea>")," 의 배경 이미지를 만들어봅니다. (기본적으로 크기가 조정가능하기 때문에 textarea를 사용하였습니다)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'\x3c!-- index.html --\x3e\n<!DOCTYPE html>\n<style>\n  textarea {\n    background-image: paint(checkerboard);\n  }\n</style>\n<textarea></textarea>\n<script>\n  CSS.paintWorklet.addModule("checkerboard.js");\n<\/script>\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'// checkerboard.js\nclass CheckerboardPainter {\n  paint(ctx, geom, properties) {\n    // 보통의 canvas에서 사용하듯이 `ctx`를 사용합니다\n    const colors = ["red", "green", "blue"];\n    const size = 32;\n    for (let y = 0; y < geom.height / size; y++) {\n      for (let x = 0; x < geom.width / size; x++) {\n        const color = colors[(x + y) % colors.length];\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.rect(x * size, y * size, size, size);\n        ctx.fill();\n      }\n    }\n  }\n}\n// 만든 class를 등록합니다\nregisterPaint("checkerboard", CheckerboardPainter);\n')),(0,r.kt)("p",null,"이전에 ",(0,r.kt)("inlineCode",{parentName:"p"},"<canvas>")," 를 사용했다면 이 코드가 익숙해 보일 것입니다. 라이브 ",(0,r.kt)("a",{parentName:"p",href:"https://googlechromelabs.github.io/houdini-samples/paint-worklet/checkerboard/"},"데모"),"를 확인해보세요."),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"Paint worklet을 지원하지 않는 브라우저"),(0,r.kt)("p",null,"작성할 당시에 Chrome만이 paint worklet을 구현했습니다. 다른 모든 브라우저 공급업체로부터 긍정적인 신호가 있지만, 큰 진전이 없습니다. 최신 정보를 얻으려면 ",(0,r.kt)("a",{parentName:"p",href:"https://ishoudinireadyyet.com/"},"Is Houdini Ready Yet?"),"을 정기적으로 확인하십시오. 그동안 paint worklet을 지원하지 않더라도 점진적인 개선 기능을 사용하여 코드를 계속 실행해도 됩니다. 예상대로 작동하게 하려면 CSS와 JS의 두 위치에서 코드를 조정해야 합니다."),(0,r.kt)("p",null,"JS에서 paint worklet에 대한 지원 감지는 ",(0,r.kt)("inlineCode",{parentName:"p"},"CSS")," 객체를 확인하여 수행할 수 있습니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'if ("paintWorklet" in CSS) {\n  CSS.paintWorklet.addModule("mystuff.js");\n}\n')),(0,r.kt)("p",null,"CSS 에서는 두가지 옵션이 있습니다. ",(0,r.kt)("inlineCode",{parentName:"p"},"@supports")," 를 사용할 수 있습니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"@supports (background: paint(id)) {\n  /* ... */\n}\n")),(0,r.kt)("p",null,"더 간결한 트릭은 CSS가 알 수 없는 기능이 있을 경우 전체 프로퍼티 선언을 무효화하고 무시한다는 사실을 이용하는 것입니다. 먼저 paint worklet을 사용하지 않고 그 뒤에 두며 프로퍼티를 두 번 지정하면 점진적인 향상 효과를 볼 수 있습니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"textarea {\n  background-image: linear-gradient(0, red, blue);\n  background-image: paint(myGradient, red, blue);\n}\n")),(0,r.kt)("p",null,"paint worklet을 지원하는 브라우저에서 ",(0,r.kt)("inlineCode",{parentName:"p"},"background-image"),"의 두 번째 선언이 첫 번째 선언을 덮어씁니다. paint worklet을 ",(0,r.kt)("em",{parentName:"p"},"지원하지 않는")," 브라우저에서는 두 번째 선언이 유효하지 않으며, 첫 번째 선언이 그대로 적용되어 버립니다."),(0,r.kt)("hr",null),(0,r.kt)("h2",null,"CSS Paint 폴리필"),(0,r.kt)("p",null,"다양한 용도로 ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/GoogleChromeLabs/css-paint-polyfill"},"CSS Paint Polyfill"),"을 사용하여 최신 브라우저에 CSS Custom Paint 및 Paint Worklets 지원을 추가할 수도 있습니다."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"이 글이 마음에 드신다면 아래에서 더 확인해 보세요 :)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@jatin.krr/your-ultimate-guide-to-kubernetes-78836ef73072"},"https://medium.com/@jatin.krr/your-ultimate-guide-to-kubernetes-78836ef73072")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@jatin.krr/your-ultimate-guide-to-docker-9c6f66963e4b"},"https://medium.com/@jatin.krr/your-ultimate-guide-to-docker-9c6f66963e4b")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://javascript.plainenglish.io/connect-bluetooth-devices-using-javascript-891d586750c8"},"https://javascript.plainenglish.io/connect-bluetooth-devices-using-javascript-891d586750c8")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@jatin.krr/top-45-newsletters-for-developers-4542007b149b"},"https://medium.com/@jatin.krr/top-45-newsletters-for-developers-4542007b149b")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@jatin.krr/everything-you-need-to-know-about-markdown-8f9239524af3"},"https://medium.com/@jatin.krr/everything-you-need-to-know-about-markdown-8f9239524af3")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@jatin.krr/ultimate-nodejs-packages-100-resources-2022-edition-list-72561e134a83"},"https://medium.com/@jatin.krr/ultimate-nodejs-packages-100-resources-2022-edition-list-72561e134a83"))),(0,r.kt)("hr",null),(0,r.kt)("p",null,"즐거운 코딩되세요!"))}u.isMDXComponent=!0},3366:function(e,t,n){function a(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}n.d(t,{Z:function(){return a}})}}]);
//# sourceMappingURL=component---src-pages-posts-putting-javascript-in-your-css-mdx-f52ff5ed82f68a5c44ed.js.map
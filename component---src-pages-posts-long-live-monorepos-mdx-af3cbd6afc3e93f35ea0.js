"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[514],{6678:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(7294),r=n(5414),p=function(){var e=(0,a.createRef)(),t=(0,a.useState)("pending"),n=t[0],r=t[1];return(0,a.useEffect)((function(){var t=document.createElement("script");t.onload=function(){return r({status:"success"})},t.onerror=function(){return r({status:"failed"})},t.async=!0,t.src="https://utteranc.es/client.js",t.setAttribute("repo","doong-jo/blog"),t.setAttribute("issue-term","pathname"),t.setAttribute("theme","preferred-color-scheme"),t.setAttribute("crossorigin","anonymous"),e.current.appendChild(t)}),[]),a.createElement("div",{className:"comments-wrapper"},"failed"===n&&a.createElement("p",null,"Error. Please try again."),"pending"===n&&a.createElement("p",null,"Loading script..."),a.createElement("div",{ref:e}))},l=n(9327);function o(e){var t=e.children,n=e.pageContext.frontmatter,o=n.title,m=n.description,i=n.keywords,c=n.url,u=n.image,s=n.date;return a.createElement("div",{id:"post-body",className:"markdown-body dark"},a.createElement(l.Z,null),a.createElement(r.Z,null,a.createElement("title",null,o),a.createElement("meta",{name:"description",content:m}),a.createElement("meta",{name:"keywords",content:i}),a.createElement("meta",{name:"author",content:"doong-jo"}),a.createElement("meta",{property:"og:type",content:"website"}),a.createElement("meta",{property:"og:title",content:o}),a.createElement("meta",{property:"og:site_name",content:o}),a.createElement("meta",{property:"og:description",content:m}),a.createElement("meta",{property:"og:image",content:u}),a.createElement("meta",{property:"og:url",content:c}),a.createElement("meta",{name:"twitter:title",content:o}),a.createElement("meta",{name:"twitter:description",content:m}),a.createElement("meta",{name:"twitter:image",content:u}),a.createElement("link",{rel:"canonical",href:c})),a.createElement("time",null,s),t,a.createElement(p,null))}},1356:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return o},default:function(){return c}});var a=n(3366),r=(n(7294),n(4983)),p=n(6678),l=["components"],o={},m={_frontmatter:o},i=p.Z;function c(e){var t=e.components,n=(0,a.Z)(e,l);return(0,r.kt)(i,Object.assign({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",null,"Lerna는 공식적으로 죽었다. 모노레포가 영원하길"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"원문: ",(0,r.kt)("a",{parentName:"p",href:"https://betterprogramming.pub/lerna-is-officially-dead-long-live-monorepos-9853c80a7b0e"},"https://betterprogramming.pub/lerna-is-officially-dead-long-live-monorepos-9853c80a7b0e"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"4가지 도구를 사용하여 JavaScript 모노레포를 효율적으로 관리할 수 있습니다.")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/1400/1*HOIXYzC17oKEWc5p4gMIwg.png",alt:"image1.png"})),(0,r.kt)("p",null,"모노레포 접근 방식은 모든 종속성을 관리하는 좋은 방법입니다. 그리고 이는 몇 년 동안 뜨거운 주제였습니다. 모노레포는 잘 정의된 관계를 통해 개별 프로젝트를 유지할 수 있는 좋은 방법입니다. 즉각적인 이점 중 하나는 ",(0,r.kt)("inlineCode",{parentName:"p"},"ESLint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Prettier"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeScript")," 등과 같은 구성을 서로 다른 프로젝트를 통해 공유하여 일관성을 보장할 수 있다는 점입니다."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"npm"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"yarn")," 및 ",(0,r.kt)("inlineCode",{parentName:"p"},"pnpm"),"과 같은 도구는 모노레포를 기본적으로 지원합니다. 그러나 몇몇 기능을 지원하려는 의도가 전혀 없기에 이에 따른 결핍이 있습니다. 이것이 ",(0,r.kt)("inlineCode",{parentName:"p"},"Lerna"),"가 활동한 영역이었습니다. 이것의 목표는 패키지를 빌드, 조정 및 게시할 수 있도록 확장성을 향상시키고 만드는 것이었습니다."),(0,r.kt)("p",null,"Lerna는 최근에 공식적으로 수명이 다했습니다. 비록 메인테이너였던 ",(0,r.kt)("inlineCode",{parentName:"p"},"@evocateur"),"가 그의 불타는 목소리와 프로젝트를 포기하려는 의도를 밝혔지만, 그것은 2020년 4월까지 공식화되지 않았었습니다."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"중요한 참고: 이 프로젝트는 현재 ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/lerna/lerna/issues/2703"},"유지 관리되지 않습니다"),". 모노레포 관리를 위한 대체 도구 채택을 고려하십시오. — Lerna의 Readme.md입니다.")),(0,r.kt)("p",null,"이 프로젝트는 매일 ",(0,r.kt)("inlineCode",{parentName:"p"},"130만")," 건 이상의 다운로드가 지속적으로 발생하고 있지만 그 이상으로 넘어가지는 않을 것입니다. 왜 그럴까요? 제작자는 그것을 수정하기보다는 다시 만들기를 열망할 것입니다. 최신 툴링의 성능과 경쟁할 수 없었습니다. 비록 많은 사람들이 여전히 ",(0,r.kt)("inlineCode",{parentName:"p"},"Lerna"),"를 사랑하고 즐긴다고 해도, 이제는 나아가야 할 때입니다."),(0,r.kt)("p",null,"그렇다면 JavaScript/TypeScript 모노레포 에코시스템을 구축할 때 우리가 선택할 수 있는 것은 무엇일까요? 이 글에서는 가장 인기 있는 도구를 알아보려고 합니다."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"업데이트"),": 이 글이 게시된 후 내용이 뒤바뀌었습니다. Lerna의 제작자가 프로젝트를 ",(0,r.kt)("strong",{parentName:"p"},"Nrwl")," 🚀🚀에게 넘기기로 결정했습니다. 그들의 로드맵은 여전히 공개되어야 합니다. 지난 한 해 동안 Lerna가 비활성화된 동안 뒤쳐졌습니다.")),(0,r.kt)("h2",null,"Yarn, Npm, and Pnpm"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/1400/1*KgmML7r4OsnNdDikiVfiBg.png",alt:"image2.png"})),(0,r.kt)("p",null,'앞서 언급했듯이 "npm", "yarn", "pnpm"은 이미 네이티브 모노레포 지원으로 출하되고 있습니다. 그렇다면 "Lerna"나 다른 툴이 정말 필요한지 자문해 볼 필요가 있습니다. 당신의 모노레포는 그렇게 복잡합니까?'),(0,r.kt)("p",null,"얀이 선구자였습니다. 2020년 10월 출시 버전 7에서 npm에 도착했습니다. 이 세 가지 사이에는 많은 유사점이 있습니다."),(0,r.kt)("p",null,'"pnpm"에서 작업 공간 구성은 "pnpm-workspace.yaml"에 있고 "yarn" 및 "npm"에서는 루트 패키지에 있습니다.제이슨입니다'),(0,r.kt)("p",null,"'npm' 작업영역 사용 예제입니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// /.package.json\n{\n  // ...\n  "workspaces": ["./packages/*"]\n}\n')),(0,r.kt)("p",null,"테스트와 같은 명령을 실행하려면 npm의 ",(0,r.kt)("inlineCode",{parentName:"p"},"--workspaces"),"와 ",(0,r.kt)("inlineCode",{parentName:"p"},"pnpm"),"의 ",(0,r.kt)("inlineCode",{parentName:"p"},"-r")," 또는 ",(0,r.kt)("inlineCode",{parentName:"p"},"recursive"),"를 사용할 수 있습니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"# prune all workspaces\npnpm -r exec -- rm -rf node_modules && rm pnpm-lock.yaml\n# run all tests for all workspaces with scope @doppelmutzi\npnpm recursive run test --filter @doppelmutzi/\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"yarn"),"의 한 가지 특징은 ",(0,r.kt)("inlineCode",{parentName:"p"},"workspace:")," 참조를 동적으로 대체하여 종속성 프로세스를 단순화할 수 있다는 것입니다. 이는 매우 편리합니다."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "dependencies": {\n    "star": "workspace:*",\n    "caret": "workspace:^",\n    "tilde": "workspace:~",\n    "range": "workspace:^1.2.3",\n    "path": "workspace:path/to/baz"\n  }\n}\n')),(0,r.kt)("p",null,"그 세 가지 중에서 어떤 것이 가장 좋습니까? 아마 npm이 빠르게 따라잡고 있지만 좀 더 성숙한 특징을 가지고 있기 때문에 실을 뽑을 것 같습니다. pnpm은 디스크 사용과 같은 다른 이점도 있지만, 이는 실베리를 통해 달성할 수 있습니다."),(0,r.kt)("p",null,"그 세 가지 중 어떤 것을 언제 사용할까요? 상대적으로 규모가 작은 프로젝트에만 해당됩니다. 왜냐하면 이 프로젝트의 조정 측면이 없기 때문입니다. 복잡한 종속성 그래프 또는 릴리스가 필요한 경우 다른 도구를 선택하는 것이 좋습니다."))}c.isMDXComponent=!0},3366:function(e,t,n){function a(e,t){if(null==e)return{};var n,a,r={},p=Object.keys(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}n.d(t,{Z:function(){return a}})}}]);
//# sourceMappingURL=component---src-pages-posts-long-live-monorepos-mdx-af3cbd6afc3e93f35ea0.js.map